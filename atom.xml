<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ConnorZJ&#39;s Blog</title>
  
  <subtitle>Nothing is True, Everything is Permitted.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.connorzj.github.io/"/>
  <updated>2020-06-16T13:18:42.595Z</updated>
  <id>http://www.connorzj.github.io/</id>
  
  <author>
    <name>Connor</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot之rest服务（十二）</title>
    <link href="http://www.connorzj.github.io/2020/04/27/SpringBoot%E4%B9%8Brest%E6%9C%8D%E5%8A%A1/"/>
    <id>http://www.connorzj.github.io/2020/04/27/SpringBoot%E4%B9%8Brest%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-04-27T13:02:08.000Z</published>
    <updated>2020-06-16T13:18:42.595Z</updated>
    
    <content type="html"><![CDATA[<p>REST是一种API的模式，一种风格，通过这种形式，我们能把API的风格统一起来。</p><p>而通过HTTP的几种请求方式，能够利用其指定对资源的操作类型，一般常用的HTTP方法包括GET、POST、DELETE、PUT等。</p><p>在springboot中构建一个restful的项目，是非常快捷方便的。再搭配Spring Data JPA使用，能极大地简化了日常的代码量。下面来看看如何使用！</p><h2 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h2><p>首先创建一个springboot项目，依赖勾选web、jpa、mysql和<strong>rest repositories</strong>依赖。</p><p>创建一个实体类，待会测试用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(name = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/jdbc?userSSL=false&amp;serverTimezone=GMT</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update</span></span><br><span class="line"><span class="meta">spring.jpa.database</span>=<span class="string">mysql</span></span><br><span class="line"><span class="meta">spring.jpa.database-platform</span>=<span class="string">mysql</span></span><br><span class="line"><span class="meta">spring.jpa.show-sql</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.dialect</span>=<span class="string">org.hibernate.dialect.MySQL57Dialect</span></span><br></pre></td></tr></table></figure><p>当然还需要一个dao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Person</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个简单的RESTful的springboot服务就已经搭建好了！</strong>是不是非常的简单快捷！！！</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>ps：这里使用postman测试效果</p><p>众所周知，HTTP的GET方法一般适用于查询某个资源的，在这个项目里，就使用下面的链接访问资源即可</p><p><a href="http://localhost:8080/persons" target="_blank" rel="noopener">http://localhost:8080/persons</a></p><p>这个是项目服务地址加上实体类名小写再加上一个’s’，这样的话，就能将表中所有的数据查询出来</p><p><img src="http://qiniuyun.zijie.fun/20200504100952.png" alt=""></p><p>可以看到，查询出来的数据是空的，这是因为表中还未添加数据，这里通过POST请求添加一条数据试试，添加新资源的方法是POST方法</p><p><img src="http://qiniuyun.zijie.fun/20200504101501.png" alt=""></p><p>请求发送后，可以看到将这条数据返回了，表示资源添加成功！</p><p>返回的信息中，可以看到有个地址是<a href="http://localhost:8080/persons/1，这个表示在查询的地址后加上一个id，这样就能根据id进行查询了。" target="_blank" rel="noopener">http://localhost:8080/persons/1，这个表示在查询的地址后加上一个id，这样就能根据id进行查询了。</a></p><p>下面再添加几条数据，请求一下<a href="http://localhost:8080/persons试试效果" target="_blank" rel="noopener">http://localhost:8080/persons试试效果</a></p><p><img src="http://qiniuyun.zijie.fun/20200504101851.png" alt=""></p><p>可以看到，所有的数据被查询出来了，而且还带着分页的信息给我们，这个时候将请求地址修改成分页查询的接口<a href="http://localhost:8080/persons?page=1&amp;size=2" target="_blank" rel="noopener">http://localhost:8080/persons?page=1&amp;size=2</a></p><p><img src="http://qiniuyun.zijie.fun/20200504102114.png" alt=""></p><p>这个接口是请求第二页，每页两条数据的意思，能够看到，返回的除了数据，又给我们提供了first（第一页）、prev（上一页）、last（最后一页）的接口路径。</p><p>接下来看看如何进行更新操作：</p><p><img src="http://qiniuyun.zijie.fun/20200504102513.png" alt=""></p><p>更新一般是用PUT方法，通过id，将要更新的数据写到请求体里，这样就能更新成功。</p><p>而删除方法也与以上类似，只需要通过DELETE方法，在将id传入即可删除：</p><p><img src="http://qiniuyun.zijie.fun/20200504102705.png" alt=""></p><p><img src="http://qiniuyun.zijie.fun/20200504102734.png" alt=""></p><p>可以看到删除成功！</p><p>以上就是使用自带的增删改查方法的使用。</p><h2 id="自定义查询方法"><a href="#自定义查询方法" class="headerlink" title="自定义查询方法"></a>自定义查询方法</h2><p>以上的通用CRUD方法肯定不能满足日常需求，所以springboot rest也支持客制化的接口。</p><p>比如现在增加一个根据name的关键字查询，在JPA中，这样的方法应该写成如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Person</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">findPersonByNameContaining</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来使用<a href="http://localhost:8080/persons/search可以查询出能够用到的所有自定义的方法：" target="_blank" rel="noopener">http://localhost:8080/persons/search可以查询出能够用到的所有自定义的方法：</a></p><p><img src="http://qiniuyun.zijie.fun/20200504103317.png" alt=""></p><p>可以看到，现在就提供了一个<strong><a href="http://localhost:8080/persons/search/findPersonByNameContaining{?name}" target="_blank" rel="noopener">http://localhost:8080/persons/search/findPersonByNameContaining{?name}</a></strong>的方法，下面使用试试看！</p><p><img src="http://qiniuyun.zijie.fun/20200504103432.png" alt=""></p><p>能够看到，通过关键字’三’，能够查询出name中有三的数据！</p><p>定制化的接口就是这么简单使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;REST是一种API的模式，一种风格，通过这种形式，我们能把API的风格统一起来。&lt;/p&gt;
&lt;p&gt;而通过HTTP的几种请求方式，能够利用其指定对资源的操作类型，一般常用的HTTP方法包括GET、POST、DELETE、PUT等。&lt;/p&gt;
&lt;p&gt;在springboot中构建一
      
    
    </summary>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之整合redis（十一）</title>
    <link href="http://www.connorzj.github.io/2020/04/25/SpringBoot%E4%B9%8B%E6%95%B4%E5%90%88redis/"/>
    <id>http://www.connorzj.github.io/2020/04/25/SpringBoot%E4%B9%8B%E6%95%B4%E5%90%88redis/</id>
    <published>2020-04-24T16:00:00.000Z</published>
    <updated>2020-06-16T13:05:18.029Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，redis是一种nosql，它的速度非常快，因为它采用的是内存读写，完全基于内存，数据结构也简单，使用单线程，避免了没必要的上下文切换等等。</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>既然redis这么好，我肯定要学习如何使用它。首先创建一个springboot项目，依赖勾选web、redis依赖。</p><p>springboot自动配置的redis底层是lettuce，一般我们使用的是Jedis，但在此处只是演示，就只使用lettuce，若要使用Jedis，则在pom中引入Jedis依赖，再排除lettuce即可。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">106.15.44.65</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>配置只需配这些即可，但前提是要保证你的redis客户端支持远程访问。</p><p>redis在springboot中的配置都是靠<strong>RedisAutoConfiguration</strong>这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(</span><br><span class="line">    proxyBeanMethods = <span class="keyword">false</span></span><br><span class="line">)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;RedisOperations<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(</span>&#123;RedisProperties<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123;LettuceConnectionConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">JedisConnectionConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(</span><br><span class="line">        name = &#123;<span class="string">"redisTemplate"</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够看到第三个方法使用到的是<strong>StringRedisTemplate</strong>，这个是用来处理字符串类型的变量的bean，接下来我们就能够在例子中通过它去使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">        String name = ops.get(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"set"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">        ops.set(<span class="string">"name"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line">        stringRedisTemplate.expire(<span class="string">"name"</span>,<span class="number">1000</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里写了两个简单的例子，先调用set方法，在redis中写入一个name的key，value为zhangsan，设置过期时间是1000，单位是秒。</p><p><img src="http://qiniuyun.zijie.fun/20200502132432.png" alt=""></p><p>在redis中可以看到这个键值对也被设置成功了，接下来调用get方法。</p><p><img src="http://qiniuyun.zijie.fun/20200502132514.png" alt=""></p><p>能够看到，在springboot中使用redis是非常简单的一件事！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;众所周知，redis是一种nosql，它的速度非常快，因为它采用的是内存读写，完全基于内存，数据结构也简单，使用单线程，避免了没必要的上下文切换等等。&lt;/p&gt;
&lt;h2 id=&quot;开始使用&quot;&gt;&lt;a href=&quot;#开始使用&quot; class=&quot;headerlink&quot; title=&quot;开
      
    
    </summary>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之整合JPA（十）</title>
    <link href="http://www.connorzj.github.io/2020/04/22/SpringBoot%E4%B9%8B%E6%95%B4%E5%90%88JPA/"/>
    <id>http://www.connorzj.github.io/2020/04/22/SpringBoot%E4%B9%8B%E6%95%B4%E5%90%88JPA/</id>
    <published>2020-04-21T16:00:00.000Z</published>
    <updated>2020-06-16T13:04:25.171Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习的是springboot中的Spring Data JPA，那么，JPA是什么？</p><p>JPA是Java Persistence API的简称，中文名字是Java持久层API。<strong>它是Sun公司提出的一种持久化规范</strong>，提供了一套仅仅是规范的东西，而真正使用它，靠的是Hibernate等厂商实现了这套规范后提供的一套产品。</p><p>Spring Data JPA是Spring官方在基于现有的ORM框架、JPA规范，以Hibernate为基础构建的一套解决方案，以非常方便的方式提供给用户访问数据库和操作，简化了常用的增删改查等功能的使用。</p><p>下面来看看Spring Data JPA如何使用！</p><h2 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h2><p>首先创建一个springboot项目，依赖选择Web、Mysql Driver和JPA三个依赖。</p><p><img src="http://qiniuyun.zijie.fun/20200501112713.png" alt=""></p><p>进入项目之中，第一肯定是要创建一个实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(name = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实体类上有个注解是@Entity，这个注解是必须的，它的作用是标注这个类是一个数据表对应的实体类，数据库中创建的表名要和类名保持一致。name属性是可选的，表示对应着数据库中的表。</p><p>@Id注解也是必须的，它修饰的属性表示数据表中的主键，若不标注则报错。</p><p>@GeneratedValue注解的用处是标注主键的生成策略，strategy属性填所要选择的策略。一般有四个策略，分别是AUTO、IDENTITY、SEQUENCE、TABLE，若不选择，则会默认使用AUTO，由JPA自动选择合适的策略。IDENTITY则是采用数据库主键自增的策略。</p><p>另外还有一个@Column注解，这个注解也是放在属性之上，表示这个字段对应着数据表中字段的详细信息，有name、nullable、length属性。name表示该表字段名，默认属性名和字段名一致。nullable表示该字段是否可以为空。length表示该字段的长度。</p><p>除了以上注解之外还有很多注解能够使用，在此就不一一描述。</p><p>那么说了这么多注解能够对应数据表的信息，他们是怎么真正用到的呢？</p><p>接下来看看application.properties文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/jdbc?userSSL=false&amp;serverTimezone=GMT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.jpa.show-sql</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.jpa.database</span>=<span class="string">mysql</span></span><br><span class="line"><span class="meta">spring.jpa.database-platform</span>=<span class="string">mysql</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.dialect</span>=<span class="string">org.hibernate.dialect.MySQL57Dialect</span></span><br></pre></td></tr></table></figure><p>除了上面的mysql驱动配置之外，主要是要来看看下面的JPA的配置。</p><p>spring.jpa.show-sql：表示是否展示sql语句，默认为false。如为true的话，则在使用JPA后，会在控制台将执行的sql语句打印出来。</p><p>下面两个是选择数据库平台信息，这里使用的是mysql。</p><p>spring.jpa.hibernate.ddl-auto这个配置的用处是对表的ddl操作，它有四个对应的值，分别是：</p><ul><li>create：每次加载hibernate时，都会删除上一次的表，然后根据实体类生成对应的表，哪怕两次之间没有执行任何的数据的改变，也会执行此操作。若上一次的表中有数据的话，也会清空数据，这也是会导致数据表信息丢失的重要原因之一。</li><li>create-drop：每次加载hibernate的时候都会根据实体类生成对应的表，但是在sessionFactory一关闭，表就会自动删除，比如是在关闭启动的项目的时候。</li><li>update：第一次加载hibernate的时候，会根据实体类生成对应的表，之后再加载hibernate的时候，会根据实体类的更新自动更新表结构，而且不会删除以前的数据。</li><li>validate：每次加载hibernate的时候，都会去校验数据表的结构，只会去校验结构，而不能去创建新的表。</li></ul><p>spring.jpa.properties.hibernate.dialect这个配置是选择数据库对应的方言，这里选择mysql的。</p><p>接下来就是写重要的数据库接口了，来看看数据库接口怎么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个接口层就写好了，可以开始使用了:smile:</p><p>我第一次看到这个时候的反应是：<strong>what？？？这样就没了？？？</strong></p><p>这里重要的东西是这个dao继承的JpaRepository接口，之前已经说过JPA是一套规范，而Hibernate则去实现了它，所以我们使用的时候，其实是调用JPA的接口，内容的话Hibernate已经帮我们实现好了。</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>构建完了项目，接下来就是使用的时候了，首先创建一个Controller，用来接收请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">listAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = userDao.findAll();</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://qiniuyun.zijie.fun/20200501120342.png" alt=""></p><p>在数据库中已经先有两条数据了，在这里使用Postman请求这个接口看看效果：</p><p><img src="http://qiniuyun.zijie.fun/20200501120438.png" alt=""></p><p>可以看到请求成功，也返回了数据</p><p><img src="http://qiniuyun.zijie.fun/20200501120517.png" alt=""></p><p>也能看到控制台打印了执行的sql语句。</p><p>所以在springboot中，使用JPA就能非常方便的访问数据库，极大的简化了以前的操作。</p><h2 id="使用关键字查询"><a href="#使用关键字查询" class="headerlink" title="使用关键字查询"></a>使用关键字查询</h2><p>回到JPARepository接口，可以看到它里面的方法。</p><p><img src="http://qiniuyun.zijie.fun/20200501121351.png" alt=""></p><p>这里也有很多方法是我们不常用到的，但如果我们经常要使用增删改查的操作，建议将Dao接口继承CrudRepository接口</p><p><img src="http://qiniuyun.zijie.fun/20200501121818.png" alt=""></p><p>在这个接口下，几乎所有方法都是适合在增删改查操作频繁的使用场景，例如是save、delete、findById。</p><p>下面举个findById的例子，在controller中使用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"find"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String id = request.getParameter(<span class="string">"id"</span>);</span><br><span class="line">        Optional&lt;User&gt; user = userDao.findById(Integer.valueOf(id));</span><br><span class="line">        <span class="keyword">return</span> user.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里已经将UserDao继承了CrudRepository，可以看到调用findById返回的是Optional<User>，这个东西是Java1.8开始有的，能够使对象不为空，避免空指针的错。</p><p><img src="http://qiniuyun.zijie.fun/20200501122552.png" alt=""></p><p>能够看到，通过这种方法能够根据id查询到数据。</p><p>但这个时候有另一个疑问：如果我不是要根据id去查，而是要根据name这个字段去查数据怎么办，我可没有看到这个接口呀。</p><p>既然hibernate实现了JPA，肯定也考虑到这种情况了。</p><p>接下来我在UserDao中写一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方法名，就能够通过name这个字段查询到User的信息。下面测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"findByName"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findByName</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">        User user = userDao.findByName(name);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://qiniuyun.zijie.fun/20200501125154.png" alt=""></p><p>hibernate中，可以使用特定的关键字去组合方法，这样就能够让hibernate自动配置sql语句进行查询。</p><p>关键字及其例子</p><table><thead><tr><th><strong>Keyword</strong></th><th><strong>Sample</strong></th><th><strong>JPQL snippet</strong></th></tr></thead><tbody><tr><td><code>And</code></td><td><code>findByLastnameAndFirstname</code></td><td><code>… where x.lastname = ?1 and x.firstname = ?2</code></td></tr><tr><td><code>Or</code></td><td><code>findByLastnameOrFirstname</code></td><td><code>… where x.lastname = ?1 or x.firstname = ?2</code></td></tr><tr><td><code>Is</code>, <code>Equals</code></td><td><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code></td><td><code>… where x.firstname = ?1</code></td></tr><tr><td><code>Between</code></td><td><code>findByStartDateBetween</code></td><td><code>… where x.startDate between ?1 and ?2</code></td></tr><tr><td><code>LessThan</code></td><td><code>findByAgeLessThan</code></td><td><code>… where x.age &lt; ?1</code></td></tr><tr><td><code>LessThanEqual</code></td><td><code>findByAgeLessThanEqual</code></td><td><code>… where x.age &lt;= ?1</code></td></tr><tr><td><code>GreaterThan</code></td><td><code>findByAgeGreaterThan</code></td><td><code>… where x.age &gt; ?1</code></td></tr><tr><td><code>...</code></td><td><code>...</code></td><td><code>...</code></td></tr></tbody></table><p>除此之外还有很多关键字，详情见 <a href="https://docs.spring.io/spring-data/jpa/docs/2.2.7.RELEASE/reference/html/#jpa.query-methods" target="_blank" rel="noopener">Spring Data JPA 官方文档</a> </p><h2 id="自定义sql查询"><a href="#自定义sql查询" class="headerlink" title="自定义sql查询"></a>自定义sql查询</h2><p>这一节讲的是如何使用自定义sql查询，因为在某个时候，除了官方提供的接口外，很难使用一个简单的方法去处理复杂逻辑的查询，这里就可以使用自己写的sql语句去查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(value=<span class="string">"select * from user where id = (select max(id) from user)"</span>,nativeQuery=<span class="keyword">true</span>)</span><br><span class="line">    <span class="function">User <span class="title">getMaxIdUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用jpa的@Query注解，value中填入要使用的sql，nativeQuery使用true，表名是一条原生的查询语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"findMaxIdUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findMaxIdUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = userDao.getMaxIdUser();</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://qiniuyun.zijie.fun/20200501131533.png" alt=""></p><p>能够看到，通过这种方式，能够是jpa支持原生sql语句，接下来看一条插入的insert语句怎么使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"insert into user(name,address) values(?1,?2)"</span>, nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function">Integer <span class="title">insertNewUser</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name, @<span class="title">Param</span><span class="params">(<span class="string">"address"</span>)</span> String address)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新操作比查询操作略微复杂那么一点点，在sql语句中可以看到，values后面放的是<strong>?1</strong>和<strong>?2</strong>，这个表示接受在方法参数中接收的顺序，在方法参数中使用@Param注解来绑定变量。</p><p>除此之外，还要加上@Modifying注解，表明这是一个修改的操作，既然是更新，肯定也要加上@Transactional注解，这时一个事务的注解，如果不加则会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"insertNewUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">insertNewUser</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">        String address = request.getParameter(<span class="string">"address"</span>);</span><br><span class="line">        Integer id = userDao.insertNewUser(name, address);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://qiniuyun.zijie.fun/20200501133028.png" alt=""></p><p><img src="http://qiniuyun.zijie.fun/20200501133038.png" alt=""></p><p>通过结果可以看到操作成功了！</p><p>以上就是在springboot中如何使用Spring Data JPA，学习使我进步，分享也希望能够帮助到大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天学习的是springboot中的Spring Data JPA，那么，JPA是什么？&lt;/p&gt;
&lt;p&gt;JPA是Java Persistence API的简称，中文名字是Java持久层API。&lt;strong&gt;它是Sun公司提出的一种持久化规范&lt;/strong&gt;，提供了一套仅
      
    
    </summary>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之整合MyBatis（九）</title>
    <link href="http://www.connorzj.github.io/2020/04/20/SpringBoot%E4%B9%8B%E6%95%B4%E5%90%88MyBatis/"/>
    <id>http://www.connorzj.github.io/2020/04/20/SpringBoot%E4%B9%8B%E6%95%B4%E5%90%88MyBatis/</id>
    <published>2020-04-19T16:00:00.000Z</published>
    <updated>2020-06-16T13:04:52.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-boot-之整合-MyBatis"><a href="#spring-boot-之整合-MyBatis" class="headerlink" title="spring boot 之整合 MyBatis"></a>spring boot 之整合 MyBatis</h1><p>这一章接着上一章的JdbcTemplate来说。</p><p>一般来讲，JdbcTemplate不会在项目中真正使用的，而经常使用的到的就是MyBatis和JPA了。MyBatis是一个支持SQL查询，存储过程和高级映射的持久层框架，和JdbcTemplate不同的是，我们可以不用对结果集进行处理，而能直接获得返回对象。</p><p>下面开始使用！</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先创建一个springboot项目，依赖勾选web、mysql驱动依赖和MyBatis依赖即可。</p><p>在pom文件中可以看到，springboot项目提供原生的依赖的话，是以spring-boot-starter-xxx形式写的，而mybatis的依赖则是xxx-spring-boot-starter，这个说明mybatis并不是spring官方提供的，而是由第三方提供的。虽然不知道这个有什么用处，不过还是觉得奇怪的知识增加了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.44<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/jdbc</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:/mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>在SSM框架中用过mybatis的同学应该都知道，一般mybatis是以一个接口对应着一个mapper.xml文件生效的。这里就定义一下mapper.xml文件的存放地址，就放在resources下面的mapper文件夹下，下面所有的.xml文件都是mapper的文件。</p><h2 id="撸代码"><a href="#撸代码" class="headerlink" title="撸代码"></a>撸代码</h2><p>接下来就是老套路了，创建一个UserService，一个UserDao，还有一个user-mapper.xml。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">listAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.listUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">listUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.connor.mybatis.dao.UserDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listUser"</span> <span class="attr">resultType</span>=<span class="string">"org.connor.mybatis.bean.User"</span>&gt;</span></span><br><span class="line">        select * from user ;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的mapper.xml中，namespace写的是对应的UserDao的包路径+名字，这样配置，那么就会让UserDao和user-mapper.xml绑定。需要注意的是，在xml中写的sql语句的id，要和dao中的方法名保持一致。</p><h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MybatisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(userService.listAllUsers());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普普通通的一个测试方法，点击运行看看效果：</p><p><img src="http://qiniuyun.zijie.fun/20200420230900.png" alt=""></p><p>可以看到，在springboot中整合mybatis还是非常方便的，所以我想说一句，<strong>springboot牛逼</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-boot-之整合-MyBatis&quot;&gt;&lt;a href=&quot;#spring-boot-之整合-MyBatis&quot; class=&quot;headerlink&quot; title=&quot;spring boot 之整合 MyBatis&quot;&gt;&lt;/a&gt;spring boot 之整合 M
      
    
    </summary>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之JdbcTemplate的使用（八）</title>
    <link href="http://www.connorzj.github.io/2020/04/17/SpringBoot%E4%B9%8BJdbcTemplate%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.connorzj.github.io/2020/04/17/SpringBoot%E4%B9%8BJdbcTemplate%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-04-17T13:00:21.000Z</published>
    <updated>2020-06-16T13:13:17.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-boot-之-JdbcTemplate-的使用"><a href="#spring-boot-之-JdbcTemplate-的使用" class="headerlink" title="spring boot 之 JdbcTemplate 的使用"></a>spring boot 之 JdbcTemplate 的使用</h1><p>不管是在SpringMVC时代，还是现在的SpringBoot乃至SpringCloud，数据库的使用都是非常非常非常基础的。而在其中，往往有许多种集成数据持久化的方式，有JdbcTemplate，也有MyBatis，还有JPA等。接下来将要分成几个文章来学习一下在springboot中如何使用以上三种方式。</p><h2 id="JdbcTemplate项目初始化"><a href="#JdbcTemplate项目初始化" class="headerlink" title="JdbcTemplate项目初始化"></a>JdbcTemplate项目初始化</h2><ol><li>首先当然要创建一个项目，老规矩，先选择依赖。选择Web依赖、JDBC依赖和MySql驱动的依赖。</li></ol><p>ps：如果不想使用Mysql，也可自行选择其他数据库的依赖。</p><p><img src="http://qiniuyun.zijie.fun/20200419223051.png" alt=""></p><ol start="2"><li>接着配置一下pom文件，将mysql驱动的依赖的版本，换成适合当下使用的mysql版本的驱动依赖。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.44<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><p>在springboot中使用JdbcTemplate不需要做过多的配置，只要在application.properties中添加以下配置即可，这些配置，如果有springMVC经验的话，都很容易理解</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/jdbc?userSSL=false</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>以上就是一些数据库的驱动、url、用户名和密码。当然，根据url也能看到，我当前使用的数据库名是jdbc，只要根据自己的实际情况更改即可。</p><p>其中有一个userSSL=false，这个是因为在mysql某些版本及以上都需要使用SSL去连接，这里只是用来测试，所有就写false就好了。</p><p>当然还需要一个数据表，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`jdbc`</span>.<span class="string">`user`</span>(  </span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">  <span class="string">`address`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">   <span class="keyword">KEY</span>(<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_general_ci;</span><br></pre></td></tr></table></figure><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>首先创建一个User实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"><span class="comment">// getters and setters and toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再创建一个UserService类，里面编写使用的实际代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        String name = user.getName();</span><br><span class="line">        String address = user.getAddress();</span><br><span class="line">        String sql = <span class="string">"insert into user(name,address) values(?,?)"</span>;</span><br><span class="line">        <span class="keyword">int</span> update = jdbcTemplate.update(sql, <span class="keyword">new</span> Object[]&#123;name, address&#125;);</span><br><span class="line">        <span class="keyword">return</span> update;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JdbcTemplate中，增删改一般都可以使用update方法，第一个参数放sql语句，第二个参数放参数数组即可。</p><h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p>编写测试类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JdbctemplateApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"张三"</span>);</span><br><span class="line">        user.setAddress(<span class="string">"zhangsanAddress"</span>);</span><br><span class="line">        userService.addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该测试类，在数据库中能看到，新增方法成功了。</p><p><img src="http://qiniuyun.zijie.fun/20200419225132.png" alt=""></p><p>接下来再试一试查询方法。</p><p>在UserService中增加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from user where id = ?"</span>;</span><br><span class="line">    RowMapper rowMapper = <span class="keyword">new</span> RowMapper() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setId(resultSet.getInt(<span class="string">"id"</span>));</span><br><span class="line">            user.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">            user.setAddress(resultSet.getString(<span class="string">"address"</span>));</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    List&lt;User&gt; users = jdbcTemplate.query(sql, <span class="keyword">new</span> Object[]&#123;id&#125;, rowMapper);</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再在测试方法中调用这个方法，运行效果如下：</p><p><img src="http://qiniuyun.zijie.fun/20200419225525.png" alt=""></p><p>更改和删除方法与之类似，就不在这里赘述了，有兴趣的可以自己去试一试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-boot-之-JdbcTemplate-的使用&quot;&gt;&lt;a href=&quot;#spring-boot-之-JdbcTemplate-的使用&quot; class=&quot;headerlink&quot; title=&quot;spring boot 之 JdbcTemplate 的使用&quot;&gt;
      
    
    </summary>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之AOP的使用（七）</title>
    <link href="http://www.connorzj.github.io/2020/04/15/SpringBoot%E4%B9%8BAOP%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.connorzj.github.io/2020/04/15/SpringBoot%E4%B9%8BAOP%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-04-15T12:56:45.000Z</published>
    <updated>2020-06-16T13:12:50.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-boot-之AOP的使用"><a href="#spring-boot-之AOP的使用" class="headerlink" title="spring boot 之AOP的使用"></a>spring boot 之AOP的使用</h1><p>众所周知，springboot是基于spring应用的，spring的两大核心是DI和AOP，所以在springboot之中，这两个核心同样能体现出来。DI在springboot太常见了，随便找个源码都能看到的它的踪迹，本期就来讲讲AOP在springboot中如何使用。</p><h2 id="AOP的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a>AOP的使用</h2><p>aop其实用的地方也非常的广泛，比如说是打印日志，aop对于这个就非常的擅长。在每个方法进入前或者返回后，都能够通过aop来打印相关的日志。下面就直接来看看如何自定义这样的简易的日志。</p><p>首先创建一个controller类，这个肯定是必须的，日志都能在这里的方法前后打印输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">printHello</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次就是这次的重点了，创建一个aop的配置类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* org.connor.aop..*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before method!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after method!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after returning method!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after throwing method!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before around method!!!"</span>);</span><br><span class="line">        point.proceed();</span><br><span class="line">        System.out.println(<span class="string">"after around method!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这个类上定义两个注解，分别是注册成组件的component注解，和声明是切面的注解。</p><p>其次就是声明一个切点，这里使用@PointCut注解，里面的值是execution(* org.connor.aop..<em>.</em>(..))，其含义是：</p><p>第一个<strong>“*”</strong>号表示匹配任意的返回类型，两个<strong>“.”</strong>号表示匹配aop包及其所有的子包，第二个<strong>“*”</strong>号表示任意的类，第三个<strong>“*”</strong>表示匹配任意的方法，后年括号中的两个<strong>“.”</strong>表示匹配任意的参数，那么这个表达式就是匹配任意的类中的带有任意参数的任意方法。</p><p>在这里也可以把表达式换成execution(* org.connor.aop.controller* . *(..))，表示只匹配controller包下的所有类的方法。</p><p>接下来就将这个切点织入，就是一些前置通知，后置通知，环绕通知…….</p><p>接下来测试一下效果：</p><p><img src="http://qiniuyun.zijie.fun/20200416232801.png" alt=""></p><p>这里能够看到通知都能够生效，其实在springboot中使用aop也是一件很方便的事，稍微做一些配置，就能够在项目中实现非常高大上的功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-boot-之AOP的使用&quot;&gt;&lt;a href=&quot;#spring-boot-之AOP的使用&quot; class=&quot;headerlink&quot; title=&quot;spring boot 之AOP的使用&quot;&gt;&lt;/a&gt;spring boot 之AOP的使用&lt;/h1&gt;&lt;p&gt;众所
      
    
    </summary>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之ControllerAdvice注解的用法（六）</title>
    <link href="http://www.connorzj.github.io/2020/04/14/SpringBoot%E4%B9%8BControllerAdvice%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://www.connorzj.github.io/2020/04/14/SpringBoot%E4%B9%8BControllerAdvice%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2020-04-14T12:59:10.000Z</published>
    <updated>2020-06-16T13:13:02.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-boot-之-ControllerAdvice注解的用法"><a href="#spring-boot-之-ControllerAdvice注解的用法" class="headerlink" title="spring boot 之 ControllerAdvice注解的用法"></a>spring boot 之 ControllerAdvice注解的用法</h1><p>@ControllerAdvice这个注解不是在springboot独有的，它在springMVC就已经被广泛的使用了，但为什么还要在springboot之中重新学习如何使用呢？<strong>那还不是我以前没怎么使用过嘛​ :joy:(逃过的课还是要补回来的)</strong></p><h2 id="ControllerAdvice的使用场景"><a href="#ControllerAdvice的使用场景" class="headerlink" title="ControllerAdvice的使用场景"></a>ControllerAdvice的使用场景</h2><p>@ControllerAdvice注解看名字就能够知道，是对Controller类的一个增强。到底如何增强呢？来看看它的功能有哪些。</p><ul><li>全局异常处理</li><li>全局数据绑定</li><li>全局数据预处理</li></ul><h2 id="全局数据绑定"><a href="#全局数据绑定" class="headerlink" title="全局数据绑定"></a>全局数据绑定</h2><p>全局数据绑定可以用来在每个Controller类中，使用到一些全局的初始化的数据。只要在ControllerAdvice中配置一下，就能够达到初始化参数的效果。</p><p>首先创造一个类，标记上ControllerAdvice注解，然后在里面方法定义一个List集合，并给这个集合赋值，在方法上添加一个ModelAttribute注解，并在此注解的参数給一值。这样，就达到了集合与这个值绑定了的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerAdviceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span>(value = <span class="string">"username"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">initListData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"张三"</span>);</span><br><span class="line">        list.add(<span class="string">"李四"</span>);</span><br><span class="line">        list.add(<span class="string">"王五"</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是使用这个集合的时候了，在Controller中新建一个方法，方法参数就放一个Model对象，使用model.asMap()方法就能将全局绑定的数据取出来，取出的格式是一个map集合，key是在ModelAttribute中定义的，value自然就与之绑定的值。此时我们将这个值取出来，并且强转成List。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/listAll"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">listAll</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; usernameMap = model.asMap();</span><br><span class="line">        List&lt;String&gt; usernameList = (List&lt;String&gt;) usernameMap.get(<span class="string">"username"</span>);</span><br><span class="line">        <span class="keyword">return</span> usernameList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面上可以看到效果，返回的就是在initListData中存入的list集合的数据。</p><p><img src="http://qiniuyun.zijie.fun/20200414231858.png" alt=""></p><h2 id="全局数据预处理"><a href="#全局数据预处理" class="headerlink" title="全局数据预处理"></a>全局数据预处理</h2><p>假如我有两个对象，一个Parent和一个Son，他们的属性都是name和age，那么我在controller方法里同时接收这两个对象，同时请求中也传入name和age的值，此时会发生什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getters and setters and toString</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getters and setters and toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveParent</span><span class="params">(Parent parent, Son son)</span></span>&#123;</span><br><span class="line">        System.out.println(parent);</span><br><span class="line">        System.out.println(son);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://qiniuyun.zijie.fun/20200414234042.png" alt=""></p><p><img src="http://qiniuyun.zijie.fun/20200414233954.png" alt=""></p><p>通过上述测试，可以看到，方法入参根本判断不了name和age到底应该给到哪个对象，这个时候就到了<strong>ControllerAdvice</strong>大展身手的时候了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerAdviceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span>(value = <span class="string">"parent"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initParent</span><span class="params">(WebDataBinder binder)</span></span>&#123;</span><br><span class="line">        binder.setFieldDefaultPrefix(<span class="string">"parent."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span>(value = <span class="string">"son"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initSon</span><span class="params">(WebDataBinder binder)</span></span>&#123;</span><br><span class="line">        binder.setFieldDefaultPrefix(<span class="string">"son."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveParent</span><span class="params">(@ModelAttribute(<span class="string">"parent"</span>)</span> Parent parent, @<span class="title">ModelAttribute</span><span class="params">(<span class="string">"son"</span>)</span> Son son) </span>&#123;</span><br><span class="line">    System.out.println(parent);</span><br><span class="line">    System.out.println(son);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ControllerAdvice配置中，添加如上两个方法，含义是：分别将传入的入参的前缀绑定到相应的对象之中，此时重启项目并再测试一下。</p><p><img src="http://qiniuyun.zijie.fun/20200414234623.png" alt=""></p><p><img src="http://qiniuyun.zijie.fun/20200414234635.png" alt=""></p><p>可以看到，数据预处理成功了。</p><h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>ControllerAdvice最广泛使用的场景，就是处理全局异常了。</p><p>什么 处理全局异常？我的理解是，在controller的每一个方法都有可能抛出异常，有时候异常可能是自己定义的，有时候异常也可能是RunTimeException。这种情况下，在每一个方法里处理，就会显得比较累赘，而通过全局异常处理，可以达到配置一处而处处生效的效果。比如说是，在ControllerAdvice中配置了返回异常的信息，前端就能看到到底是什么异常被抛出了，而不是各种异常不同格式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/null"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Parent <span class="title">getNullPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Parent parent = <span class="keyword">null</span>;</span><br><span class="line">        parent.getName();</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在controller中故意设置一个会抛空指针的错，然后在配置中增加以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerAdviceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(NullPointerException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">handleNullPointException</span>(<span class="title">NullPointerException</span> <span class="title">e</span>,<span class="title">HttpServletResponse</span> <span class="title">response</span>) <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">            writer.write(<span class="string">"空指针异常！"</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExceptionHandler注解是用来声明处理哪一个异常的，比如这里声明处理空指针异常，那么在controller中抛出了空指针异常的时候，都会走到这个方法里面</p><p><img src="http://qiniuyun.zijie.fun/20200415001800.png" alt=""></p><p>之后也可以写多个类似这个的方法，声明不同的异常，可以让处理的异常类型丰富起来，也可以在方法里返回一个视图ModelAndView或者返回一个错误对象，这种方式也是一种<strong>前端友好向</strong>的做法！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-boot-之-ControllerAdvice注解的用法&quot;&gt;&lt;a href=&quot;#spring-boot-之-ControllerAdvice注解的用法&quot; class=&quot;headerlink&quot; title=&quot;spring boot 之 Controll
      
    
    </summary>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之静态资源访问（五）</title>
    <link href="http://www.connorzj.github.io/2020/04/13/SpringBoot%E4%B9%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/"/>
    <id>http://www.connorzj.github.io/2020/04/13/SpringBoot%E4%B9%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/</id>
    <published>2020-04-12T16:00:00.000Z</published>
    <updated>2020-06-16T13:03:45.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-boot-之静态资源访问"><a href="#spring-boot-之静态资源访问" class="headerlink" title="spring boot 之静态资源访问"></a>spring boot 之静态资源访问</h1><p>以前在springMVC项目之中，如果需要访问静态资源的话，一般是需要在spring-mvc.xml文件中配置以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/images/**"</span> <span class="attr">location</span>=<span class="string">"/images/"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/js/**"</span> <span class="attr">location</span>=<span class="string">"/js/"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/**"</span> <span class="attr">location</span>=<span class="string">"/css/"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>但是在springboot之中，访问静态资源的方式就更加的简单粗暴了！</p><p>下面来看看在springboot中如何访问静态资源。</p><h2 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h2><p>第一步肯定是创建项目啦~依赖选择web即可。</p><p>首先搜索类<strong>WebMvcAutoConfiguration</strong>，再找到其内部类<strong>WebMvcAutoConfigurationAdapter</strong>，定位到它的<strong>addResourceHandlers</strong>方法，可以看到有一个staticPathPattern变量</p><p><img src="http://qiniuyun.zijie.fun/20200413225427.png" alt=""></p><p>点进去看一看这个变量的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.staticPathPattern = <span class="string">"/**"</span>;</span><br></pre></td></tr></table></figure><p>这个就是类似于在springMVC中配置的location，两个**表示的是匹配任意一层路径。</p><p>再看下面一行的源码，这个比较长，主要要看的是this.resourceProperties.getStaticLocations()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations())).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br></pre></td></tr></table></figure><p>看到这个点进去看，就能看到其实这个staticLocations的值是一个String的数组，元素有四个分别是”classpath:/META-INF/resources/“、”classpath:/resources/“、”classpath:/static/“、”classpath:/public/“。于是可以猜测，在springboot中，静态资源可以放在以上四个路径下，且优先级是按照顺序从高到低排序的。</p><p>再返回到刚刚很长的一行代码的地方，在点击WebMvcAutoConfiguration.getResourceLocations()方法，可以看到：返回了locations数组里面，除了之前提到的四个路径，还有一个<strong>SERVLET_LOCATIONS</strong>的东西，这个东西的值就是一个斜杠（”/“），对应的就是当前项目的根路径。</p><p><img src="http://qiniuyun.zijie.fun/20200413230821.png" alt=""></p><p><img src="http://qiniuyun.zijie.fun/20200413230938.png" alt=""></p><p>所以现在猜测，在springboot中，静态资源的默认映射路径分别为：</p><ul><li>classpath:/META-INF/resources/</li><li>classpath:/resources/</li><li>classpath:/static/</li><li>classpath:/public/</li><li>/</li></ul><p>接下来就是验证我们的猜测是否正确的时候了！</p><h2 id="验证猜测"><a href="#验证猜测" class="headerlink" title="验证猜测"></a>验证猜测</h2><p>首先我们在项目下分别在各自的路径创建五个location.js文件，里面就写上各自的路径</p><p><img src="C:%5CUsers%5C10203%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200413232428801.png" alt="image-20200413232428801"></p><p>启动项目，访问<a href="localhost:8080/location.js">localhost:8080/location.js</a>，打印了一条，就删掉相应路径的location.js，看看将会打印出了什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">classpath:&#x2F;META-INF&#x2F;resources&#x2F;</span><br><span class="line">classpath:&#x2F;resources&#x2F;</span><br><span class="line">classpath:&#x2F;static&#x2F;</span><br><span class="line">classpath:&#x2F;public&#x2F;</span><br><span class="line">webapp:&#x2F;</span><br></pre></td></tr></table></figure><p>通过上述打印的信息可以判断，我们之前的猜测是正确的！</p><h2 id="自定义路径"><a href="#自定义路径" class="headerlink" title="自定义路径"></a>自定义路径</h2><p>通过上面的操作，我们知道了springboot中关于静态资源的默认的访问路径，但我想访问自定义路径的静态资源怎么办呢？</p><p>其实这样也是可以的！首先看看之前看的源码<strong>staticLocations</strong>的地方，这个变量所在的类上有个注解是定义了这个前缀是spring.resources</p><p><img src="http://qiniuyun.zijie.fun/20200413233302.png" alt=""></p><p>所以我们在application.properties中，配置一个这个前缀加上staticLocations的配置，就可以实现自定义的静态资源的访问路径了。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.resources.static-locations</span>=<span class="string">classpath:/myresources/</span></span><br></pre></td></tr></table></figure><p><img src="http://qiniuyun.zijie.fun/20200413233645.png" alt=""></p><p><img src="http://qiniuyun.zijie.fun/20200413233655.png" alt=""></p><p>除了配置properties之外，还有另一种方式—那肯定就是通过注解的方式来配置啦~</p><p>首先注释掉properties的内容避免干扰，然后在包中创建一个类，重要的是实现<strong>WebMvcConfigurer</strong>接口，并重写<strong>addResourceHandlers</strong>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">"/**"</span>).addResourceLocations(<span class="string">"classpath:/myresources/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-boot-之静态资源访问&quot;&gt;&lt;a href=&quot;#spring-boot-之静态资源访问&quot; class=&quot;headerlink&quot; title=&quot;spring boot 之静态资源访问&quot;&gt;&lt;/a&gt;spring boot 之静态资源访问&lt;/h1&gt;&lt;p&gt;以前
      
    
    </summary>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之JSON解析（四）</title>
    <link href="http://www.connorzj.github.io/2020/04/12/SpringBoot%E4%B9%8BJSON%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.connorzj.github.io/2020/04/12/SpringBoot%E4%B9%8BJSON%E8%A7%A3%E6%9E%90/</id>
    <published>2020-04-12T13:01:17.000Z</published>
    <updated>2020-06-16T13:13:35.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-boot-之-JSON-解析（四）"><a href="#spring-boot-之-JSON-解析（四）" class="headerlink" title="spring boot 之 JSON 解析（四）"></a>spring boot 之 JSON 解析（四）</h1><h2 id="JSON有什么用"><a href="#JSON有什么用" class="headerlink" title="JSON有什么用"></a>JSON有什么用</h2><p>JSON (JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>说到底，JSON就是用来进行数据交互的那个<strong>数据</strong>。在前后端分离的情况下，前端负责数据展示，后台负责处理业务逻辑，这之间数据交互时，就可以用到JSON了。</p><h2 id="怎么在项目中使用"><a href="#怎么在项目中使用" class="headerlink" title="怎么在项目中使用"></a>怎么在项目中使用</h2><p>在spring4以前，可以在controller的方法上加上注解@ResponseBody，这个注解表明该对象是需要序列化成JSON字符串返回的，而也可以在参数前加上注解@RequestBody，表示这个入参接收到的是JSON字符串，需要被反序列化成对象使用。</p><p>在spring4以后，可以用上@RestController注解在controller类上，可以实现统一配置，这样就不需要在每一个方法前加上注解了。</p><p>不管是对象序列化成JSON字符串，还是JSON字符串反序列化成对象，底层这种灵活的消息转换机制就是通过一个类：HttpMessageConverter来实现的。我们在springboot项目中，可以找到一个类<em>HttpMessageConvertersAutoConfiguration</em>,在里面可以看到：</p><ul><li><p>有个条件注解是存在HttpMessageConverter类才生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;HttpMessageConverter<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>还有个注解表示在项目中可以自动配置三种JSON工具，分别是Jackson、Gson和Json-B</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;JacksonHttpMessageConvertersConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">GsonHttpMessageConvertersConfiguration</span>.<span class="title">class</span>, <span class="title">JsonbHttpMessageConvertersConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br></pre></td></tr></table></figure></li></ul><p>接下来看看怎么使用</p><h3 id="Jackson的使用"><a href="#Jackson的使用" class="headerlink" title="Jackson的使用"></a>Jackson的使用</h3><p>创建一个springboot项目，依赖只勾选Web依赖就可以了，在Maven依赖中可以看到，web依赖了json，json默认又依赖了jackson，所以，我们在Controller中添加一个@RestController注解，就能够用到Jackson了。</p><p><img src="http://qiniuyun.zijie.fun/20200412130148.png" alt=""></p><p>下面创建一个bean类对象，一个controller，在controller中创建若干个Person对象并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">listAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Person p = <span class="keyword">new</span> Person();</span><br><span class="line">            p.setName(<span class="string">"张"</span>+i);</span><br><span class="line">            p.setAddress(<span class="string">"地址"</span>+i);</span><br><span class="line">            p.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">            list.add(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动项目，输入访问地址，可以看到效果图</p><p><img src="http://qiniuyun.zijie.fun/20200412130609.png" alt=""></p><h3 id="自定义格式"><a href="#自定义格式" class="headerlink" title="自定义格式"></a>自定义格式</h3><p>emmmmmmm，效果是出来了，但是这个日期格式有点看得不顺眼**</p><p>既然是Jackson是一个JSON，那肯定可以配置的呀~</p><p>首先在Person对象的birthday属性上，加上这么一行注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示要将birthday以特定的格式年-月-日输出，接下来重启项目看看效果</p><p><img src="http://qiniuyun.zijie.fun/20200412131033.png" alt=""></p><p>这样就看得顺眼多了！</p><p><strong>但转头一想，如果项目里面有很多的这种日期属性的对象，那么我要在每一个这样的属性上都加上这一行注解吗？</strong></p><h3 id="深入浅出"><a href="#深入浅出" class="headerlink" title="深入浅出"></a>深入浅出</h3><p>其实不用，我们可以实现统一化配置</p><p>首先我们来看一看Jackson是怎么默认实现的，找到类<strong>JacksonHttpMessageConvertersConfiguration</strong>，看到其中有一个方法是：</p><p><img src="http://qiniuyun.zijie.fun/20200412131941.png" alt=""></p><p>这个表示，如果MappingJackson2HttpMessageConverter类没有提供这样一个bean的话，springboot就会使用这个默认的bean来配置，那我如果自己提供一个MappingJackson2HttpMessageConverter的bean会怎么样呢？</p><p><strong>想了就做</strong>，首先在路径下创建一个config包，在里面创建JsonMvcConfig类，类的内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonMvcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MappingJackson2HttpMessageConverter <span class="title">mappingJackson2HttpMessageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MappingJackson2HttpMessageConverter converter = <span class="keyword">new</span> MappingJackson2HttpMessageConverter();</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy/MM/dd"</span>));</span><br><span class="line">        converter.setObjectMapper(om);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，注释掉Person类属性里的@JsonFormat注解，重启项目，就能看到效果了</p><p><img src="http://qiniuyun.zijie.fun/20200412132733.png" alt=""></p><p>到现在我们也能看到，重新提供了一个MappingJackson2HttpMessageConverter的bean，能够是springboot使用我们自定义的方法，而其中真正生效的，其实是ObjectMapper类。</p><p>我们在看看另一个类：<strong>JacksonAutoConfiguration</strong>，在其中能看到</p><p><img src="http://qiniuyun.zijie.fun/20200412133248.png" alt=""></p><p>这个和上一个类似，也是缺省使用了<strong>ObjectMapper</strong>的bean，那如果我不提供<strong>MappingJackson2HttpMessageConverter</strong>，而使用<strong>MappingJackson2HttpMessageConverter</strong>行得通吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonMvcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() &#123;</span></span><br><span class="line"><span class="comment">//        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();</span></span><br><span class="line"><span class="comment">//        ObjectMapper om = new ObjectMapper();</span></span><br><span class="line"><span class="comment">//        om.setDateFormat(new SimpleDateFormat("yyyy/MM/dd"));</span></span><br><span class="line"><span class="comment">//        converter.setObjectMapper(om);</span></span><br><span class="line"><span class="comment">//        return converter;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">ObjectMapper <span class="title">objectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">        <span class="keyword">return</span> om;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上面的代码改一改，现在只提供<strong>ObjectMapper</strong>，试一试能不能生效</p><p><img src="http://qiniuyun.zijie.fun/20200412133719.png" alt=""></p><p><strong>答案是可以的！！</strong></p><p>至此，就可以比较了解了，JSON在springboot中是如何生效的，以及自定义配置JSON的格式。</p><h3 id="Gson的使用"><a href="#Gson的使用" class="headerlink" title="Gson的使用"></a>Gson的使用</h3><p>上面介绍了如何使用Jackson，而springboot中提供了除Jackson外，还有Gson的配置。</p><p>要使用Gson，首先修改一下pom文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将jackson的依赖排除掉，并引入gson依赖，可以看到gson没有版本号，这时因为springboot-start已经集成了gson</p><p>通过以上配置，则在项目中classpath里提供了默认的Gson的bean，所以就能直接用了，打印结果如下</p><p><img src="http://qiniuyun.zijie.fun/20200412234500.png" alt=""></p><p>要自定义格式的话，也如同Jackson一样，提供一个自定义的<strong>GsonHttpMessageConverter</strong>的bean，详细配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonMvcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">GsonHttpMessageConverter <span class="title">gsonHttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GsonHttpMessageConverter gsonHttpMessageConverter = <span class="keyword">new</span> GsonHttpMessageConverter();</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson().newBuilder().setDateFormat(<span class="string">"yyyy-MM-dd"</span>).create();</span><br><span class="line">        gsonHttpMessageConverter.setGson(gson);</span><br><span class="line">        <span class="keyword">return</span> gsonHttpMessageConverter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来测试一下效果</p><p><img src="http://qiniuyun.zijie.fun/20200412235257.png" alt=""></p><p>这样就生效了，所以使用Gson也是非常方便的！</p><h3 id="fastjson的使用"><a href="#fastjson的使用" class="headerlink" title="fastjson的使用"></a>fastjson的使用</h3><p>为什么要使用fastjson呢？</p><p>看名字其实就看得出来，那就是-fast(快)，而且这个库还是<strong>国产</strong>的，当然要支持支持啦~</p><p>话不多说直接开撸，首先在pom中引入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.68<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>像前两种使用方式一样，在配置中提供一个<strong>FastJsonHttpMessageConverter</strong>的bean，然后类似的配置一配！下面是配置和效果图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonMvcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">FastJsonHttpMessageConverter <span class="title">fastJsonHttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FastJsonHttpMessageConverter fastJsonHttpMessageConverter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">        FastJsonConfig config = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">        config.setDateFormat(<span class="string">"yyyy&amp;MM&amp;dd"</span>);</span><br><span class="line">        fastJsonHttpMessageConverter.setFastJsonConfig(config);</span><br><span class="line">        <span class="keyword">return</span> fastJsonHttpMessageConverter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://qiniuyun.zijie.fun/20200413000345.png" alt=""></p><p>发现这个是乱码，于是在application.properties中加上这么个两句就可以了</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.http.encoding.charset</span>=<span class="string">utf-8</span></span><br><span class="line"><span class="meta">spring.http.encoding.force</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-boot-之-JSON-解析（四）&quot;&gt;&lt;a href=&quot;#spring-boot-之-JSON-解析（四）&quot; class=&quot;headerlink&quot; title=&quot;spring boot 之 JSON 解析（四）&quot;&gt;&lt;/a&gt;spring boot 之 
      
    
    </summary>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之整合视图层（三）</title>
    <link href="http://www.connorzj.github.io/2020/04/08/SpringBoot%E4%B9%8B%E6%95%B4%E5%90%88%E8%A7%86%E5%9B%BE%E5%B1%82/"/>
    <id>http://www.connorzj.github.io/2020/04/08/SpringBoot%E4%B9%8B%E6%95%B4%E5%90%88%E8%A7%86%E5%9B%BE%E5%B1%82/</id>
    <published>2020-04-07T16:00:00.000Z</published>
    <updated>2020-06-16T13:06:03.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-boot整合视图层"><a href="#spring-boot整合视图层" class="headerlink" title="spring boot整合视图层"></a>spring boot整合视图层</h1><p>在springMVC的项目中，与视图层交互的传统的做法是通过JSP构造页面，使用后台传来的数据再来渲染页面。然而，现如今的技术潮流里，JSP技术以及在被逐渐的淘汰了。</p><p>现在的主流技术里，可以通过freemarker、thymeleaf等静态模板引擎构建页面，也可以在前后端分离的项目中，使用vue、react等前端框架搭建页面。这几种技术，springboot都能够很好地支持。不过对于JSP来说，springboot也能够支持，只是使用配置起来会略显麻烦。</p><p>接下来我将介绍freemarker的使用。</p><h2 id="什么是FreeMarker"><a href="#什么是FreeMarker" class="headerlink" title="什么是FreeMarker"></a>什么是FreeMarker</h2><p>FreeMarker 是一款 <em>模板引擎</em>： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。</p><p>模板编写为FreeMarker Template Language (FTL)。它是简单的，专用的语言， <em>不是</em> 像PHP那样成熟的编程语言。 那就意味着要准备数据在真实编程语言中来显示，比如数据库查询和业务运算， 之后模板显示已经准备好的数据。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。</p><p><img src="http://freemarker.foofun.cn/figures/overview.png" alt="Figure"></p><h2 id="创建一个FreeMarker的springboot项目"><a href="#创建一个FreeMarker的springboot项目" class="headerlink" title="创建一个FreeMarker的springboot项目"></a>创建一个FreeMarker的springboot项目</h2><p>在创建springboot项目的时候，勾选web和freemarker的依赖</p><p><img src="http://qiniuyun.zijie.fun/image-20200408215424281.png" alt="image-20200408215424281"></p><p>创建成功后，在pom中主要是用到了两个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>FreeMarker在springboot中自动化配置生效主要靠FreeMarkerAutoConfiguration类，在这个类之中，可以看到注解中有一个<strong>@ConditionalOnClass({freemarker.template.Configuration.class, FreeMarkerConfigurationFactory.class})</strong>，表示当前配置只有在<strong>freemarker.template.Configuration</strong>和<strong>FreeMarkerConfigurationFactory</strong>存在的情况下才生效，还有一个注解是<strong>@Import({FreeMarkerServletWebConfiguration.class, FreeMarkerReactiveWebConfiguration.class, FreeMarkerNonWebConfiguration.class})</strong>，表示freemarker可以用在servlet web，reactive web和非web的项目下。</p><p>我们这个项目很明显是一个servlet web项目，点击<strong>FreeMarkerServletWebConfiguration</strong>类看里面的源码，可以看到他的构造方法里，set进去了一个<strong>FreeMarkerProperties</strong>的对象，打开这个对象一看：</p><p><img src="http://qiniuyun.zijie.fun/image-20200408222859955.png" alt="image-20200408222859955"></p><p>就能够恍然大悟，配置都是在这里写好了的：</p><ol><li><p>注解里面写了前缀为spring.freemarker，如果要自定义更改，则在application.properties中配置相应的属性</p></li><li><p>DEFAULT_TEMPLATE_LOADER_PATH表示freemarker的默认模板放在classpath:/templates中，在application.properties同级目录下，能够看到这一个templates文件夹，只要把静态文件放在这个里面，springboot就能够读取到这个的模板了</p></li><li><p>DEFAULT_SUFFIX表示默认的模板文件名的后缀，在springboot 2.2.0以前，freemarker的默认后缀名是ftl，之后则改为了ftlh，据说是这样使用更加的安全。</p><p>…………</p></li></ol><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>下面我将来写个例子，看看springboot中如何使用freemarker</p><ol><li><p>首先创建一个bean，给他一些属性，用于在页面上显示</p><p><img src="http://qiniuyun.zijie.fun/image-20200408223650676.png" alt="image-20200408223650676"></p></li><li><p>接下来创建一个controller，并在里面创建若干个Person对象，给每一个对象赋值，并将其加到Model里面，以便能够返回到页面上</p><p><img src="http://qiniuyun.zijie.fun/image-20200408224310100.png" alt="image-20200408224310100"></p></li><li><p>接下来就到了重头戏了，在templates文件夹下创建模板文件—person.ftlh</p><p><img src="http://qiniuyun.zijie.fun/image-20200408225848639.png" alt="image-20200408225848639"></p><p>在freemarker里面，使用#list的标签可以循环对象，在里面使用EL表达式，取出对象里的值</p></li><li><p>更多的freemarker标签可以 <a href="http://freemarker.foofun.cn/dgui.html" target="_blank" rel="noopener">点击此处</a></p></li></ol><h2 id="更多配置"><a href="#更多配置" class="headerlink" title="更多配置"></a>更多配置</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-boot整合视图层&quot;&gt;&lt;a href=&quot;#spring-boot整合视图层&quot; class=&quot;headerlink&quot; title=&quot;spring boot整合视图层&quot;&gt;&lt;/a&gt;spring boot整合视图层&lt;/h1&gt;&lt;p&gt;在springMVC的项目中
      
    
    </summary>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之配置文件（二）</title>
    <link href="http://www.connorzj.github.io/2020/03/25/springboot%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://www.connorzj.github.io/2020/03/25/springboot%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2020-03-24T16:00:00.000Z</published>
    <updated>2020-06-16T13:03:55.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-boot的配置文件"><a href="#spring-boot的配置文件" class="headerlink" title="spring boot的配置文件"></a>spring boot的配置文件</h1><p>通过上一章已经了解到，springboot项目是一个约定大于配置的项目，大部分的配置，通过相关的默认处理，都已经配置好了，我们直接拿来使用即可。</p><p>但还是有很多种情况，我们需要自定义一些配置，来供我们业务开发的要求，比如说配置其他的数据源之类的，这个时候，就需要自己去在配置文件中定义我们所需要的东西。</p><p>配置文件一般分为application.properties和application.yml，一个springboot项目创建之后，在src/main/resources目录下，一般会看到一个这样的配置文件(application.properties)。</p><p>对于这两种文件来说，</p><ul><li>.properties文件是以key=value的形式编写，很多种情况下，前缀大部分都相同，会造成冗余的现象。</li><li>.yml是一个可读性高，用来表达数据序列化的格式的文件。</li></ul><p>下面将介绍配置文件如何在项目中使用</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="普通注入"><a href="#普通注入" class="headerlink" title="普通注入"></a>普通注入</h3><ol><li>在application.properties中添加如下代码</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.name</span>=<span class="string">张三</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">18</span></span><br><span class="line"><span class="meta">person.address</span>=<span class="string">Mars</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在项目下创建一个javaBean，包含name，age，address属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:application.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.age&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.address&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处用了3个注解，分别是：</p><ul><li>@Component注解用来表示这个类由spring管理，把普通的pojo类实例化到spring容器中</li><li>@PropertySource注解作用是加载指定的.properties文件到spring的环境之中，配合@Value使用</li><li>@Value注解作用是将.properties中的对应的属性的值，注入到当前使用此注解的属性上面去</li></ul><ol start="3"><li>在controller中注入Person类，将person打印出来，看看是否能注入属性成功</li></ol><p><img src="http://qiniuyun.zijie.fun/image-20200331221247939.png" alt="image-20200331221247939"></p><p><img src="http://qiniuyun.zijie.fun/image-20200331221611148.png" alt="image-20200331221611148"></p><p>这里能看得到，person的属性通过properties注入成功了，但是中文出现了乱码，只要在setting中把项目的编码设置成utf-8，把<em>Transparent native-to-ascii conversion</em>前面的勾勾上，再重新编辑一下properties文件即可显示正确的字符了。</p><p><img src="http://qiniuyun.zijie.fun/image-20200331231211034.png" alt="image-20200331231211034"></p><h3 id="其他方式注入"><a href="#其他方式注入" class="headerlink" title="其他方式注入"></a>其他方式注入</h3><p>上面的方法是一般情况下使用的，但是有个缺点，就是application.properties文件的属性中，person的前缀都是一样的，只是后面的名字不同，作为一个程序员，肯定要找到更加高(偷)效(懒)的方式去写呀！</p><p>所以这个时候介绍另一种注入的方式，首先将JavaBean中的@Value注解全都去掉，而在类名上增加一个注解@ConfigurationProperties</p><p><img src="http://qiniuyun.zijie.fun/image-20200331232254800.png" alt="image-20200331232254800"></p><p>可以看到，这个注解的参数中，有一个prefix，顾名思义，是去properties中寻找以person为前缀的属性，注入到JavaBean中去。</p><p><strong>注：JavaBean的属性名称必须和properties文件中的后缀保持一致</strong></p><h3 id="yaml文件方式注入"><a href="#yaml文件方式注入" class="headerlink" title="yaml文件方式注入"></a>yaml文件方式注入</h3><p>使用yaml文件做配置的话，可以替换掉application.properties，创建一个文件名为application.yml或者application.yaml的文件。</p><p><strong>yaml配置是有序的，properties配置是无序的</strong></p><p><strong>自定义的yaml文件尚不支持使用@PropertySource注解直接注入到项目之中</strong></p><p>下面来看看如何使用yaml配置</p><ol><li>首先创建一个application.yml，语法是k: v，需要注意的是，冒号后面与值之间要有一个空格</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/connor</span></span><br></pre></td></tr></table></figure><p><img src="http://qiniuyun.zijie.fun/image-20200331234454804.png" alt="image-20200331234454804"></p><p>启动项目之后，就能看到项目的端口号改变了，项目的context-path路径也改变了。</p><ol start="2"><li>之前说到yaml文件是有序的，那么怎么体现出它的有序呢</li></ol><p>现在再在yaml中添加一下属性</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/connor</span></span><br><span class="line"><span class="attr">cluster:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><p>创建一个Cluster类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"cluster"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; hosts;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">    <span class="comment">// toString()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在controller中注入这个类，并打印出这个对象</p><p><img src="http://qiniuyun.zijie.fun/image-20200331235230413.png" alt="image-20200331235230413"></p><p>所以，yaml配置能够注入一个数组/集合，同时也是保持有序的方式注入。</p><h2 id="配置文件优先级"><a href="#配置文件优先级" class="headerlink" title="配置文件优先级"></a>配置文件优先级</h2><h3 id="哪种文件优先级高"><a href="#哪种文件优先级高" class="headerlink" title="哪种文件优先级高"></a>哪种文件优先级高</h3><p>如果说，我在项目路径下，同时存在着两种配置文件，分别是application.properties和application.yml，且每个文件的内容不一样，那么springboot项目启动之后，将会使用哪一个配置呢？</p><p>带着这个问题，我同时创建了这两个文件，且让其中的内容不一致</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/properties</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/yml</span></span><br></pre></td></tr></table></figure><p>在properties中设置端口为8081，路径为properties，在yaml文件里设置端口为8082，路径为yml，接下来，就到了启动项目的时候了</p><p><img src="http://qiniuyun.zijie.fun/image-20200402234512731.png" alt="image-20200402234512731"></p><p>项目启动后，可以看到，Tomcat的端口被设置成了8081，路径为properties，这样一来，就知道了在项目启动的时候，会去调用properties的配置了。</p><p><strong>但是结果果真如此吗？</strong></p><p>在yml中，继续添加如下代码，再重新启动项目，将cluster对象打印出来</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><p><img src="http://qiniuyun.zijie.fun/image-20200402235157255.png" alt="image-20200402235157255"></p><p>通过控制台打印可以看到，端口是8081没错，使用的是<strong>properties</strong>的配置，但同时还能打印出Cluster对象的属性，这个是由<strong>yml</strong>配置的。</p><p>至此能够得出一个结论：<strong>在properties和yml配置文件同时存在的时候，项目会将这两个配置同时加载进去，但是properties的优先级比yml高，所以不同的文件下的相同的配置，优先级高的会覆盖掉优先级低的。</strong></p><h2 id="配置文件位置问题"><a href="#配置文件位置问题" class="headerlink" title="配置文件位置问题"></a>配置文件位置问题</h2><h3 id="配置文件那应该放在哪里呢"><a href="#配置文件那应该放在哪里呢" class="headerlink" title="配置文件那应该放在哪里呢"></a>配置文件那应该放在哪里呢</h3><p>springboot配置文件可以放在一下四个地方</p><p><img src="http://qiniuyun.zijie.fun/image-20200407213856326.png" alt="image-20200407213856326"></p><p>在这几个地方放配置文件，即可用于springboot项目使用</p><h3 id="哪个地方的优先级高呢"><a href="#哪个地方的优先级高呢" class="headerlink" title="哪个地方的优先级高呢"></a>哪个地方的优先级高呢</h3><p>既然能放在多个地方，那么，很明显的问题就出现在了脑海中，假如我这四个文件都存在，那项目启动的时候优先加载哪里地方得配置文件呢？</p><p>于是我分别在这四个不同的地方，创建四个application.properties文件，然后在文件内容里面设置一个name的属性，在项目启动后，将这个name属性注入到对象中，并且打印出来，就知道哪一个优先级高，哪一个优先级低了。</p><p>而且打印第一个文件位置之后，将那个文件移除掉，继续重启项目，这样就能有了一个比较直观的感受——能够知道加载的顺序！</p><p>所以下面进行测试，打印出的顺序如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">project/config/application.properties</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">project/application.properties</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">classpath/config/application.properties</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">classpath/application.properties</span></span><br></pre></td></tr></table></figure><p>从以上结果，我们能够知道不同地方的配置文件的优先级哪一个高了！</p><h3 id="自定义配置文件位置"><a href="#自定义配置文件位置" class="headerlink" title="自定义配置文件位置"></a>自定义配置文件位置</h3><p>既然不同的位置的优先级不同，那么又有一个疑问了，如果我想指定一个位置的配置生效，这该怎么做呢？</p><p>其实这种情况，我们可以通过命令行的方式指定某个配置文件，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar springboot-demo.jar --spring.config.location=classpath:/application.properties</span><br></pre></td></tr></table></figure><p>如果在IDEA中启动项目的话，可以在配置启动参数的地方加上一个启动命令</p><p><img src="http://qiniuyun.zijie.fun/image-20200407215521417.png" alt="image-20200407215521417"></p><p>这样就能通过自定义的配置文件来启动项目了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-boot的配置文件&quot;&gt;&lt;a href=&quot;#spring-boot的配置文件&quot; class=&quot;headerlink&quot; title=&quot;spring boot的配置文件&quot;&gt;&lt;/a&gt;spring boot的配置文件&lt;/h1&gt;&lt;p&gt;通过上一章已经了解到，spr
      
    
    </summary>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot快速入门（一）</title>
    <link href="http://www.connorzj.github.io/2020/03/24/springboot%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://www.connorzj.github.io/2020/03/24/springboot%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2020-03-23T16:00:00.000Z</published>
    <updated>2020-06-16T13:18:25.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="构建方式"><a href="#构建方式" class="headerlink" title="构建方式"></a>构建方式</h2><p>spring boot项目可以通过以下几种方式搭建</p><ul><li>在spring boot网站通过maven构建下载一个压缩包，导入至IDE中</li><li>使用idea快速搭建出一个spring boot项目</li><li>……</li></ul><p>这里展示两种搭建spring boot项目的方式</p><h3 id="maven构建"><a href="#maven构建" class="headerlink" title="maven构建"></a>maven构建</h3><p>首先访问<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a>，project选择Maven Project，language选择Java，spring boot版本选择默认版本，项目元数据根据自己的需要填写，比如packaging方式是Jar还是War，JDK版本是8或以上等，构建方式是Maven，所以可以在dependencies中选择要依赖的东西，详细细节可以参考下图<br><img src="http://qiniuyun.zijie.fun/springboot-io.png" alt="image"><br>信息填写完成后，点击绿色的Generate，或者快捷键Ctrl+回车即可下载压缩包，解压之后用IDE将文件夹通过引入Maven项目的方式引入即可。</p><h3 id="idea构建"><a href="#idea构建" class="headerlink" title="idea构建"></a>idea构建</h3><p>使用idea构建spring boot项目同样很方便快速，在idea中new project，左边选择Spring Initializr，右边选择JDK，下面让你选择Service URL，默认的正好就是第一种构建方式的访问地址，可以想象得到，idea其实也是通过第一种方式创建spring boot项目的。<br><img src="http://qiniuyun.zijie.fun/idea1.png" alt="image"><br>点击next就到下一步，输入项目的元数据<br><img src="http://qiniuyun.zijie.fun/idea2.png" alt="image"><br>再点击next，就到了选择依赖的地方，还能选择spring boot的版本号，之后再finish<br><img src="http://qiniuyun.zijie.fun/idea3.png" alt="image"><br>这样进入idea的界面后，Maven会自动引入spring boot所需要的依赖包，一个spring boot项目就这样搭好了。</p><h2 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h2><p>如一般的Maven/SSM工程一样，项目目录中分别含有java、resources、test的文件夹，分别用以存放Java文件、配置文件和测试文件，还有着pom.xml，但却缺少了web.xml文件和applicationContext.properties等文件，这是为什么呢？</p><blockquote><p>spring boot遵循着约定优于配置的理念，特点是简单、快速和便捷。spring boot提供了一系列的Starter依赖来简化jar包的配置。</p></blockquote><p>所以我们创建了一个spring boot项目之后，一切工作都如我们创建了普通的SSM框架的默认配置一样，接下来，我在包结构中创建一个controller，里面写一个简单的返回字符串的方法。</p><p>src/main/java/org.connor.springbootdemo.controller</p><h5 id="Ps-controller的package目录要和SpringbootDemoApplication在同一级"><a href="#Ps-controller的package目录要和SpringbootDemoApplication在同一级" class="headerlink" title="Ps:controller的package目录要和SpringbootDemoApplication在同一级"></a>Ps:controller的package目录要和SpringbootDemoApplication在同一级</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.connor.springbootdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Connor Xiong</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Connor!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后右键点击SpringbootDemoApplication，点击run，虽然我没有手动配置Tomcat服务器，但是因为spring boot内置了Tomcat，所以run之后就是Tomcat启动起来了。<br><img src="http://qiniuyun.zijie.fun/spring-boot-1.png" alt="image"><br>在浏览器上输入localhost:8080/hello，就可以看到在HelloController中方法返回的字符串了。<br><img src="http://qiniuyun.zijie.fun/spring-boot-2.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速入门&quot;&gt;&lt;a href=&quot;#快速入门&quot; class=&quot;headerlink&quot; title=&quot;快速入门&quot;&gt;&lt;/a&gt;快速入门&lt;/h1&gt;&lt;h2 id=&quot;构建方式&quot;&gt;&lt;a href=&quot;#构建方式&quot; class=&quot;headerlink&quot; title=&quot;构建方式&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://www.connorzj.github.io/tags/spring-boot/"/>
    
  </entry>
  
</feed>
